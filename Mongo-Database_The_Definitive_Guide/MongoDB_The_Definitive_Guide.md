# MongoDB The Definitive Guide

## 몽고DB 소개
### 1.1 손쉬운 사용
- 몽고는 도큐먼트의 키와 값을 미리 정의하지 않는다.
- 고정된 스키마가 없으므로 쉽게 필드를 추가하거나 삭제할 수 있다.

### 1.2 확장 가능한 설계
- '데이터베이스를 어떻게 확장할 것인가'와 같은 어려운 의사 결정에 직면.
- 몽고는 분산 확장을 염두에 두고 설계되었다.
- 데이터를 여러 서버에 더 쉽게 분산하게 해준다.
- 도큐먼트를 자동으로 재분배하고 사용자 요청을 올바른 장비에 라우팅함으로써 클러스터 내 데이터 양과 부하를 조절할 수 있다.

### 1.3 다양한 기능
- 인덱싱
  - unique, compound, full-text 인덱싱 기능 제공
  - 중첩된 도큐먼트(nested document) 및 배열과 같은 계층 구조의 보조 인덱스도 지원함.

- 집계
  - 몽고는 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공함.
  - 집계 파이프라인(aggregation pipeline)은 데이터베이스 최적화를 최대한 활용하여 서버 측에서 비교적 간단한 일련의 단계로 데이터를 처리하는 것.

- 특수한 컬렉션 유형
  - 몽고는 로그와 같은 최신데이터를 유지하고자 세션이나 고정 크기 컬렉션(capped collection)과 같이 특정 시간에 만료해야 하는 데이터에 대해 유효 시간(time to live - TTL)컬렉션을 지원한다(!!)
  - 기준 필터(criteria filter)와 일치하는 도큐먼트에 한정된 부분 인덱스(partial index)를 지원하여 효율성을 높이고 저장 공간을 줄인다.
- 파일 스토리지
  - 몽고는 큰 파일의 파일 메타데이터를 저장하는 프로토콜을 지원한다.

### 1.4 고성능
- skip

### 1.5 몽고DB의 철학
- 결국 몽고는 확장성이 높으며 유연하고 빠른, 즉 완전한 기능을 갖춘 데이터 스토리지를 만드는 일이다.


## 몽고DB 기본
### 2.0 들어가며
- 몽고 데이터의 기본 단위는 _도큐먼트_이다.
- _컬렉션_은 테이블과 유사하다.
- 몽고의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 _데이터베이스_를 호스팅한다.
- 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 __id_를 가진다.
- 몽고 셸이라는 간단하지만 강력한 도구와 함꼐 배포된다. 자바스크립트 해석기다.

## 2.1 도큐먼트
- 몽고의 핵심은 정렬된 키와 연결된 값의 집합으로 이루어진 _도큐먼트_다.
- 해시, 딕셔너리, 맵 등과 같이 표현되는 자료구조를 말한다.
- 데이터형과 대소문자를 구별한다.
- 키가 중복될 수 없다.

## 2.2 컬렉션
### 2.2.1 동적 스키마
- 몽고는 자유롭다. "같은 컬렉션에서도 키, 값, 데이터형 모두 다르게 설정할 수 있는데 왜 굳이 컬렉션이 필요하지?"
  1. 컬렉션 별로 나뉘어져 있으면 개발자와 관리자 모두에게 편하다.
  2. 컬렉션이 분류되어있으면 쿼리로 목록을 뽑을 때 속도가 훨씬 빠르다.(ME:정리 되어있으니까.)
  3. 데이터 지역성에 좋다.
  4. 인덱스를 정의할 수 있는데 인덱스는 컬렉션 별로 정의한다.

### 2.2.2 네이밍
- 컬렉션은 이름으로 식별된다. 
  - 빈 문자열은 안된다.
  - `\0`은 사용할 수 없다.
  - 예약어는 사용될 수 없다.
  - `$`를 포함할 수 없다.

## 2.3 데이터베이스
- 몽고는 컬렉션에 도큐먼트를 그룹화할 뿐 아니라 데이터베이스에 컬렉션을 그룹 지어 놓는다.
- 몽고는 단일 인스턴스에 여러 데이터베이스를 호스팅할 수 있다.
- 한 앱의 데이터를 동일한 데이터베이스에 저장하는 것은 좋은 방식이다.

## 2.4 몽고DB 시작
- skip

## 2.5 몽고DB 셸 소개
### 2.5.1 셸 실행
- skip
### 2.5.2 몽고DB 클라이언트
- skip
### 2.5.3 셸 기본 작업
- skip
## 2.6 데이터형
### 2.6.1 기본 데이터형
- 몽고는 'JSON'과 닮았다고 생각할 수 있다.
  - JSON의 한계
    - 기본 데이터 폼이 한정적임. (배열, 객체, 문자열, 숫사, 불리언)
    - 부동소수점과 정수형을 표현하는 방법이 없고 32비트, 64비트도 구별되지 않음.
- 몽고는 JSON의 키/값 쌍 성질을 유지하면서 추가적인 데이터형을 지원한다.
  - null을 지원한다.
  - 불리언을 지원한다.
  - 숫자를 지원한다.
  - 문자열
  - 날짜
  - 정규 표현식
  - 배열
  - 내장 도큐먼트
  - 객체 ID(ObejctId())
  - 이진 데이터
  - 코드(ME: 함수를 집어넣을 수 있다..!)
### 2.6.2 날짜
- skip
### 2.6.3 배열
- skip
### 2.6.4 내장 도큐먼트
- 도큐먼트 안에 도큐먼트를 의미한다.
- 몽고는 내장 도큐먼트를 이해하고, 인덱스를 구성하고, 쿼리하며, 갱신하기 위헤 내장 도큐먼트 내부에 접근한다.
- 내장 도큐먼트를 분리하지 않으면 내장 도큐먼트를 가지고는있는 도큐먼트들을 모두 수정해야 한다.
  - ME: 그렇다고 해서 권장하지 않는다 라고는 말할 수 없을 듯.
    - 왜냐하면, 도큐먼트를 모두 1-depth를 유지하게 되면 조인이 불가피하기 때문
### 2.6.5 _id와 ObjectId
- `_id`는 컬렉션 내에서 고유하다.
- 따라서 각기 다른 두 컬렉션에서 같은 `_id`가 존재할 수 있다.
#### ObjectId
  - ObjectId는 12바이트 스토리지를 사용한다.
  - 24자리 16진수 문자열로 표현이 가능하다.
  - 흔히 거대한 16진수 문자열로 표현되기는 하지만, 실제로 문자열은 저장된 데이터의 두 배만큼 길다.
```plaintext
  0 1 2 3 4 5 6 7 8 9 10 11
  타임스탬프 랜덤       카운터(랜덤 시작 값)
  ObjectId는 위와 같은 형태로 이루어진다.
```
  - ObjectId의 첫 4바이트는 타임스탬프이다.
  - 다음 5바이트는 랜덤한 값이다. 최종 3바이트는 서로 다른 시스템의 충돌을 방지한다.
  - 9바이트 이 후부터는 1초 동안 여러 장비와 프로세스를 거쳐 유일성을 보장한다.
  - 고유한 ObjectId는 프로세스당 1초에 `1677만 7216개`까지 생성된다.
### 2.7 몽고DB 셸 사용
#### 2.7.1 셸 활용 팁
- `help`를 입력하면 셸의 내장된 도움말을 볼 수 있다.
- 데이터베이스 수준의 도움말은 `db.help()`로 알 수 있다.
- 컬렉션 수준의 도움말은 `db.foo.help()`로 알 수 있다.
- 함수의 기능을 알고 싶다면 `js`처럼 괄호를 없애면 된다.
  - `db.movies.updateOne` 입력.
  - 매개변수 순서나 어떻게 동작하는지 알 수 있다.
#### 2.7.2 셸에서 스크립트 실행하기
- 단순히 명령행에 스크립트만 넘겨서 스크립트를 사용할 수도 있다.
  - `mongo script1.js script2.js` 실행.
- 배너 출력을 막고싶으면 `--quiet` 옵션을 주면 된다.
- 스크립트는 db 변수에 대한 접근 권한을 가진다.
  - 하지만 usedb나 show collection과 같은 셸 보조자는 파일에서 동작하지 않는다.
  - 셸 보조자의 `use video`는 JS 스크립트의 `db.getSisterDB("video")`와 같은 의미이다.
  - 셸 보조자의 `show dbs`는 JS 스크립트의 `db.getMongo().getDBS()`와 같은 의미이다.
  - 셸 보조자의 `show collections`는 JS 스크립트의 `db.getCollectionNames()`와 같은 의미이다.
- 셸에 스크립트를 로드할 수도 있다. `load('script1.js')`
- 기본적으로 셸은 셸을 시작한 디렉터리에서 스크립트를 찾는다.
#### 2.7.3 .mongorc.js 만들기
- todo